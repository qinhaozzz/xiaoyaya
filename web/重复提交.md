重复提交
======
* 本单机模式
* 分布式模式

> 利用自定义注解、AOP、Guava Cache、redies实现表单防止重复提交。AOP也可以换成spring拦截器
实现理论
------
1. 通过自定义注解标识需要拦截的方法以及传递相关参数
2. AOP通过切符合条件的方法，获取注解及其属性值，通过一定规则生成key
3. 通过key在缓存获取值，如果存在在抛异常，如果不存在则生成值
4. 完成请求之后，使缓存中的值过期

代码示例
------
AOP实现
```java
// 标识注解
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface LocalLock {

    String key() default "";

    /**
     * 失效时间
     * @return
     */
    int expire() default 5;
}

// aop处理逻辑
@Aspect
@Configuration
public class LocalMethodInterceptor {
    // google Guava 中的工具类Cache
    private static final Cache<String, Object> CACHES = CacheBuilder.newBuilder()
            .maximumSize(100)
            .expireAfterWrite(5, TimeUnit.SECONDS)
            .build();

    @Pointcut("execution(public * *(..)) && @annotation(com.lim.xyyutil.annotation.LocalLock)")
    public void localLockCut() {
    }

    @Around(value = "localLockCut()")
    public Object interceptor(ProceedingJoinPoint pjp) {
        MethodSignature signature = (MethodSignature) pjp.getSignature();
        Method method = signature.getMethod();
        LocalLock localLock = method.getAnnotation(LocalLock.class);
        // key生成策略 String key = localLock.key() + pjp.getArgs()
        String key = localLock.key();
        if (!StringUtils.isEmpty(key)) {
            if (CACHES.getIfPresent(key) != null) {
                throw new RuntimeException("重复请求");
            }
            CACHES.put(key, key);
        }
        try {
            return pjp.proceed();
        } catch (Throwable throwable) {
            throw new RuntimeException("服务器异常");
        } finally {
            // key对应值失效 CACHES.invalidate(key)
            System.out.println("finally");
        }
    }
}

```
拦截器实现
```java
public class LocalLockInterceptor extends HandlerInterceptorAdapter{
  // google Guava 中的工具类Cache
  private static final Cache<String, Object> CACHES = CacheBuilder.newBuilder()
          .maximumSize(100)
          .expireAfterWrite(5, TimeUnit.SECONDS)
          .build();

	@Override
	public boolean preHandle(HttpServletRequest request,HttpServletResponse response, Object handler) throws Exception {
		if(handler instanceof HandlerMethod){
			HandlerMethod handlerMethod = (HandlerMethod) handler;
			// key生成策略
			String Key = handlerMethod.getBeanType().getName()+handlerMethod.getMethod().getName();
			// 是否标注
			LocalLock localLock = handlerMethod.getMethodAnnotation(LocalLock.class);
			if(forbiddenAnnotation!=null){
				//第一次进入设置值
				if(CACHES.getIfPresent(key) == null){
					CACHES.put(key, key);
					return true;
				}else{
					response.setContentType("text/html;charset=UTF-8");
		            response.getWriter().write("<script>alert(\"请不要重复操作！\");history.back();</script>");
		            return false;
				}
			}
		}
		return true;
	}

	@Override  
    public void postHandle(HttpServletRequest request,HttpServletResponse response, Object handler,ModelAndView modelAndView) throws Exception {  
		if(handler instanceof HandlerMethod){
			HandlerMethod handlerMethod = (HandlerMethod) handler;
			String key = handlerMethod.getBeanType().getName()+handlerMethod.getMethod().getName();
			CACHES.invalidate(key);
		}
    }
```
