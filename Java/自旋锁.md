自旋锁
======
阻塞或唤醒一个线程需要CPU状态来完成，这种状态的转换也需要消耗处理器时间。在很多场景中，同步资源的锁定时间很短，线程挂起和恢复现场的花费可能会让系统得不偿失，所以让当前线程“稍等一下”，即需要当前线程进行自旋，如果在自旋完成前锁定同步资源的线程已经释放了锁，那么当前线程就可以不必阻塞而是直接获取同步资源，从而避免切换线程的开销。这就是自旋锁。

自旋线程状态的转换
------
默认自旋次数：`10`
``` java
=>线程请求同步资源锁失败,资源被占用
if(自旋锁){
  // 不放弃CPU时间片，通过自旋等待锁释放，多次重试
}else if(非自旋锁){
  // 线程阻塞
}
=>最终获取同步资源的锁
```
> 适应性自旋锁：如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也是很有可能再次成功，进而它将允许自旋等待持续相对更长的时间。如果对于某个锁，自旋很少成功获得过，那在以后尝试获取这个锁时将可能省略掉自旋过程，直接阻塞线程，避免浪费处理器资源。
